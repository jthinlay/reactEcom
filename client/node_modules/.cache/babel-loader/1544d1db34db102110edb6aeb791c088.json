{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/jampathinlay/Desktop/react-folder/project2/crwn-clothing/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst t = require('@babel/types');\n\nconst hash = require('string-hash');\n\nconst path = require('path');\n/**\n * Basic React.Fragment check\n * We can improve it by checking import aliases if needs\n */\n\n\nconst isReactFragment = node => {\n  if (!node) return false;\n\n  if (t.isJSXFragment(node)) {\n    return true;\n  }\n\n  const _ref = node.arguments || [],\n        _ref2 = _slicedToArray(_ref, 1),\n        element = _ref2[0];\n\n  if (t.isIdentifier(element)) {\n    return element.name === 'Fragment';\n  }\n\n  if (t.isMemberExpression(element)) {\n    return element.object.name === 'React' && element.property.name === 'Fragment';\n  }\n\n  return false;\n};\n\nconst isReactElement = node => {\n  if (t.isJSXElement(node)) {\n    return true;\n  }\n\n  const callee = node.callee;\n  if (!t.isMemberExpression(callee)) return false;\n  const object = callee.object,\n        property = callee.property;\n  return object.name === 'React' && property.name === 'createElement';\n};\n\nconst isElement = node => node && isReactElement(node) && !isReactFragment(node);\n\nconst isReturned = p => {\n  const parent = p.parent;\n\n  if (t.isCallExpression(parent) || t.isConditionalExpression(parent) || t.isSequenceExpression(parent) || t.isLogicalExpression(parent)) {\n    return isReturned(p.parentPath);\n  }\n\n  return t.isReturnStatement(parent) || t.isArrowFunctionExpression(parent);\n};\n\nconst projectPath = process.cwd().toLowerCase();\n\nconst getNode = p => {\n  const parent = p.parent;\n\n  if (isReactFragment(parent)) {\n    return getNode(p.parentPath);\n  }\n\n  if (!isReturned(p)) return null;\n  let isComponent = false;\n  let componentNode = null;\n  let currentPath = p;\n  let node;\n  let parentPath;\n\n  do {\n    var _currentPath = currentPath;\n    node = _currentPath.node;\n    parentPath = _currentPath.parentPath;\n    if (parentPath && isElement(parentPath.node)) break;\n    isComponent = isComponent || t.isArrowFunctionExpression(node) || t.isFunctionExpression(node) || t.isClassMethod(node) || t.isObjectMethod(node) || t.isFunctionDeclaration(node);\n\n    if (!componentNode && isComponent) {\n      componentNode = node;\n    }\n\n    switch (currentPath.type) {\n      case 'VariableDeclaration':\n      case 'ClassDeclaration':\n      case 'ExportDefaultDeclaration':\n      case 'ExportNamedDeclaration':\n      case 'FunctionDeclaration':\n        {\n          if (!componentNode) break;\n          return {\n            rootPath: currentPath,\n            componentNode\n          };\n        }\n    }\n\n    currentPath = parentPath;\n  } while (currentPath);\n\n  return null;\n};\n\nconst getName = ({\n  rootPath\n}) => {\n  if (rootPath.type === 'ExportDefaultDeclaration' || rootPath.parent.type === 'ExportDefaultDeclaration') return 'default';\n\n  if (rootPath.type === 'VariableDeclaration') {\n    const _rootPath$node$declar = _slicedToArray(rootPath.node.declarations, 1),\n          declarator = _rootPath$node$declar[0];\n\n    return declarator.id.name;\n  }\n\n  return rootPath.node.id.name;\n};\n\nconst getId = (filename, name) => hash(\"\".concat(path.relative(projectPath, filename.toLowerCase()), \":\").concat(name).split(path.sep).join('/')).toString(16);\n\nconst buildComment = hashmap => \"__reselector__start__::\".concat(JSON.stringify(hashmap), \"::__reselector__end__\");\n\nconst getHashmapFromComment = content => {\n  const _ref3 = content.match(/__reselector__start__::(.*?)::__reselector__end__/) || [],\n        _ref4 = _slicedToArray(_ref3, 2),\n        _ref4$ = _ref4[1],\n        result = _ref4$ === void 0 ? '' : _ref4$;\n\n  if (result) return JSON.parse(result);\n  return '';\n};\n\nmodule.exports = {\n  getNode,\n  getName,\n  getId,\n  isElement,\n  isReactFragment,\n  isReactElement,\n  buildComment,\n  getHashmapFromComment\n};","map":null,"metadata":{},"sourceType":"script"}